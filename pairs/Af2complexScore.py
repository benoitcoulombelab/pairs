import argparse
import glob
import json
import os
import re
import sys
from typing import TextIO

import tqdm


class Ranking:
  def __init__(self, model: str, interaction_score: float,
      interfacial_residue_number: int,
      interfacial_contact_number: int, pitms: float, plddts: float,
      ptms: float):
    self.model = model
    self.interaction_score = interaction_score
    self.interfacial_residue_number = interfacial_residue_number
    self.interfacial_contact_number = interfacial_contact_number
    self.pitms = pitms
    self.plddts = plddts
    self.ptms = ptms


def dir_path(string: str):
  if not string or os.path.isdir(string):
    return string
  else:
    raise NotADirectoryError(string)


RANKING_METRICS = ["interface", "pitms", "plddts", "ptms"]
RANKING_METRICS_JSON = {
  "interface": "interface score",
  "pitms": "pitms",
  "plddts": "plddts",
  "ptms": "ptms"
}


def main(argv: list[str] = None):
  parser = argparse.ArgumentParser(
      description="Extract interaction score and piTM from multiple ranking JSON files"
                  " generated by AF2Complex.")
  parser.add_argument('-i', '--input', type=dir_path, default="",
                      help="Base directory to look for ranking JSON files  (default: current directory)")
  parser.add_argument('-o', '--output', type=argparse.FileType('w'),
                      default=sys.stdout,
                      help="Tab delimited output file containing scores")
  parser.add_argument('-m', '--metrics', nargs="+", choices=RANKING_METRICS,
                      default=[RANKING_METRICS[0]],
                      help="Metrics to output, first metric is used to choose best model  (default: %(default)s)")
  parser.add_argument('-n', '--name', default=r"([\w-]+)__([\w-]+)",
                      help="Regular expression to obtain protein/gene names based on PDB filename "
                           " (default: %(default)s)")
  parser.add_argument('-p', '--progress', action="store_true", default=False,
                      help="Show progress bar")
  parser.add_argument('-R', '--recycled', action="store_true", default=False,
                      help="Use recycled models in addition to regular models")
  parser.add_argument('-M', '--mapping', type=argparse.FileType('r'),
                      help="Tab delimited text file used to convert names")
  parser.add_argument('-S', '--source_column', type=int, default='1',
                      help="Column index of source names in mapping file - 1 means first column of file" +
                           "   (default: %(default)s)")
  parser.add_argument('-C', '--converted_column', type=int, default='2',
                      help="Column index of converted names in mapping file - 1 means first column of file" +
                           "   (default: %(default)s)")

  args = parser.parse_args(argv)

  multi_interaction_score(input_dir=args.input, output_file=args.output,
                          name=args.name,
                          metrics=args.metrics, progress=args.progress,
                          recycled=args.recycled,
                          mapping_file=args.mapping,
                          source_column=args.source_column - 1,
                          converted_column=args.converted_column - 1)


def multi_interaction_score(input_dir: str = "",
    output_file: TextIO = sys.stdout, name: str = r"([\w-]+)__([\w-]+)",
    metrics: [str] = [RANKING_METRICS[0]], progress: bool = False,
    recycled: bool = False,
    mapping_file: TextIO = None, source_column: int = 0,
    converted_column: int = 1):
  """
  Extract interaction score and piTM from multiple ranking JSON files generated by AF2Complex.

  :param input_dir: input directory
  :param output_file: output file
  :param name: regular expression to obtain protein/gene names based on PDB filename
  :param metrics: metrics to output, first metric is used to choose best model
  :param progress: if True, show progress bar
  :param recycled: include recycled models when considering best model
  :param mapping_file: tab delimited text file used to convert names
  :param source_column: column index of source names in mapping file
  :param converted_column: column index of converted names in mapping file
  """
  if len(metrics) == 0:
    raise AssertionError("metrics must have at least one value")
  if len([metric for metric in metrics if metric not in RANKING_METRICS]) > 0:
    raise AssertionError(
        f"metrics values must all be present in {RANKING_METRICS}")
  ranking_files = sorted(
      glob.glob("**/ranking_all_*.json", root_dir=input_dir, recursive=True))
  ranking_files = [os.path.join(input_dir, ranking_file) for ranking_file in
                   ranking_files]
  mappings = {}
  if mapping_file:
    mappings = parse_mapping(mapping_file, source_column, converted_column)
  output_file.write("Bait\tTarget")
  for metric in metrics:
    if "interface" == metric:
      output_file.write("\tInterface score")
    elif "pitms" == metric:
      output_file.write("\tTM score (piTM)")
    elif "plddts" == metric:
      output_file.write("\tpLDDT")
    elif "ptms" == metric:
      output_file.write("\tpTM")
  output_file.write("\n")
  for ranking_file in (tqdm.tqdm(ranking_files) if progress else ranking_files):
    re_match = re.search(name, ranking_file)
    if not re_match:
      raise AssertionError(
          f"Expression {name} cannot be found in filename {ranking_file}")
    bait, target = re_match.group(1, 2)
    bait = mappings[bait] if bait in mappings else bait
    target = mappings[target] if target in mappings else target
    output_file.write(f"{bait}\t{target}")
    ranking = parse_rankings(ranking_file, metrics[0], recycled)
    for metric in metrics:
      if "interface" == metric:
        output_file.write(f"\t{ranking.interaction_score}")
      elif "pitms" == metric:
        output_file.write(f"\t{ranking.pitms}")
      elif "plddts" == metric:
        output_file.write(f"\t{ranking.plddts}")
      elif "ptms" == metric:
        output_file.write(f"\t{ranking.ptms}")
    output_file.write("\n")


def parse_rankings(ranking: str, metric: str = RANKING_METRICS[0],
    use_recycled: bool = False) -> Ranking:
  """
  Computes statistics on AlphaFold's output.

  :param ranking: ranking JSON file
  :param metric: metric used to choose best model
  :param use_recycled: include recycled models when considering best model
  :return: ranking of best model
  """
  with open(ranking, 'r') as input_in:
    rankings = json.load(input_in)
  if metric not in RANKING_METRICS_JSON:
    raise AssertionError(
        f"metric {metric} not found in RANKING_METRICS ({RANKING_METRICS.keys()})")
  ranking_json = RANKING_METRICS_JSON[metric]
  if ranking_json not in rankings:
    raise AssertionError(
        f"metric {metric} not found in rankings JSON file {ranking}")
  keys = list(rankings[ranking_json].keys())
  if not use_recycled:
    keys = [key for key in rankings[ranking_json].keys() if
            "_recycled_" not in key]
  best_score = max([rankings[ranking_json][key] for key in keys])
  best_model = list(rankings[ranking_json].keys())[
    list(rankings[ranking_json].values()).index(best_score)]
  interaction_score = rankings["interface score"][best_model]
  interfacial_residue_number = rankings["interfacial residue number"][
    best_model]
  interfacial_contact_number = rankings["interficial contact number"][
    best_model]
  pitms = rankings["pitms"][best_model]
  plddts = rankings["plddts"][best_model]
  ptms = rankings["ptms"][best_model]
  return Ranking(best_model, interaction_score, interfacial_residue_number,
                 interfacial_contact_number,
                 pitms, plddts, ptms)


def parse_mapping(mapping_file: TextIO, source_column: int = 0,
    converted_column: int = 1) \
    -> dict[str, str]:
  """
  Parse mapping file.

  :param mapping_file: text delimited filename
  :param source_column: index of source id columns
  :param converted_column: index of converted id columns
  :return: dictionary of source id to converted id
  """
  mappings = {}
  for line in mapping_file:
    if line.startswith('#'):
      continue
    columns = line.rstrip('\r\n').split('\t')
    source = columns[source_column]
    converted = columns[converted_column]
    if converted:
      mappings[source] = converted
  return mappings


if __name__ == '__main__':
  main()
