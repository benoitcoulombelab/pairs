import argparse
import glob
import os
import re
import sys
import json
from typing import TextIO

import tqdm


class Ranking:
    def __init__(self, model: str, interaction_score: float, interfacial_residue_number: int,
                 interfacial_contact_number: int, pitms: float, plddts: float, ptms: float):
        self.model = model
        self.interaction_score = interaction_score
        self.interfacial_residue_number = interfacial_residue_number
        self.interfacial_contact_number = interfacial_contact_number
        self.pitms = pitms
        self.plddts = plddts
        self.ptms = ptms


def dir_path(string: str):
    if not string or os.path.isdir(string):
        return string
    else:
        raise NotADirectoryError(string)


RANKING_METRICS = ["interface", "pitms", "plddts", "ptms"]
RANKING_METRICS_JSON = {
    "interface": "interface score",
    "pitms": "pitms",
    "plddts": "plddts",
    "ptms": "ptms"
}


def main(argv: list[str] = None):
    parser = argparse.ArgumentParser(description="Extract interaction score and piTM from multiple ranking JSON files"
                                                 " generated by AF2Complex.")
    parser.add_argument('-i', '--input', type=dir_path, default="",
                        help="Base directory to look for ranking JSON files  (default: current directory)")
    parser.add_argument('-o', '--output', type=argparse.FileType('w'), default=sys.stdout,
                        help="Tab delimited output file containing scores")
    parser.add_argument('-m', '--metrics', nargs="+", choices=RANKING_METRICS, default=[RANKING_METRICS[0]],
                        help="Metrics to output, first metric is used to choose best model  (default: %(default)s)")
    parser.add_argument('-n', '--name', default=r"([\w-]+)__([\w-]+)",
                        help="Regular expression to obtain protein/gene names based on PDB filename "
                             " (default: %(default)s)")
    parser.add_argument('-p', '--progress', action="store_true", default=False,
                        help="Show progress bar")
    parser.add_argument('-R', '--recycled', action="store_true", default=False,
                        help="Use recycled models in addition to regular models")
    parser.add_argument('-M', '--mapping', type=argparse.FileType('r'),
                        help="Tab delimited text file used to convert names")
    parser.add_argument('-S', '--source_column', type=int, default='1',
                        help="Column index of source names in mapping file - 1 means first column of file" +
                             "   (default: %(default)s)")
    parser.add_argument('-C', '--converted_column', type=int, default='2',
                        help="Column index of converted names in mapping file - 1 means first column of file" +
                             "   (default: %(default)s)")

    args = parser.parse_args(argv)

    multi_interaction_score(input_dir=args.input, output_file=args.output, name=args.name,
                            metrics=args.metrics, progress=args.progress, recycled=args.recycled,
                            mapping_file=args.mapping, source_column=args.source_column - 1,
                            converted_column=args.converted_column - 1)


def multi_interaction_score(input_dir: str = "", output_file: TextIO = sys.stdout, name: str = r"([\w-]+)__([\w-]+)",
                            metrics: [str] = [RANKING_METRICS[0]], progress: bool = False, recycled: bool = False,
                            mapping_file: TextIO = None, source_column: int = 0, converted_column: int = 1):
    """
    Extract interaction score and piTM from multiple ranking JSON files generated by AF2Complex.

    :param input_dir: input directory
    :param output_file: output file
    :param name: regular expression to obtain protein/gene names based on PDB filename
    :param metrics: metrics to output, first metric is used to choose best model
    :param progress: if True, show progress bar
    :param recycled: include recycled models when considering best model
    :param mapping_file: tab delimited text file used to convert names
    :param source_column: column index of source names in mapping file
    :param converted_column: column index of converted names in mapping file
    """
    ranking_files = sorted(glob.glob("**/ranking_all_*.json", root_dir=input_dir, recursive=True))
    ranking_files = [os.path.join(input_dir, ranking_file) for ranking_file in ranking_files]
    mappings = {}
    if mapping_file:
        mappings = parse_mapping(mapping_file, source_column, converted_column)
    output_file.write("Bait\tTarget")
    for metric in metrics:
        if "interface" == metric:
            output_file.write("\tInterface score")
        elif "pitms" == metric:
            output_file.write("\tTM score (piTM)")
        elif "plddts" == metric:
            output_file.write("\tpLDDT")
        elif "ptms" == metric:
            output_file.write("\tpTM")
    output_file.write("\n")
    for ranking_file in (tqdm.tqdm(ranking_files) if progress else ranking_files):
        re_match = re.search(name, ranking_file)
        if not re_match:
            raise AssertionError(f"Expression {name} cannot be found in filename {ranking_file}")
        bait, target = re_match.group(1, 2)
        bait = mappings[bait] if bait in mappings else bait
        target = mappings[target] if target in mappings else target
        output_file.write(f"{bait}\t{target}")
        ranking = parse_rankings(ranking_file, metrics[0], recycled)
        for metric in metrics:
            if "interface" == metric:
                output_file.write(f"\t{ranking.interaction_score}")
            elif "pitms" == metric:
                output_file.write(f"\t{ranking.pitms}")
            elif "plddts" == metric:
                output_file.write(f"\t{ranking.plddts}")
            elif "ptms" == metric:
                output_file.write(f"\t{ranking.ptms}")
        output_file.write("\n")


def parse_rankings(ranking: str, metric: str = RANKING_METRICS[0], use_recycled: bool = False) -> Ranking:
    """
    Computes statistics on AlphaFold's output.

    :param ranking: ranking JSON file
    :param metric: metric used to choose best model
    :param use_recycled: include recycled models when considering best model
    :return: ranking of best model
    """
    with open(ranking, 'r') as input_in:
        rankings = json.load(input_in)
    if metric not in RANKING_METRICS_JSON:
        raise AssertionError(f"metric {metric} not found in RANKING_METRICS ({RANKING_METRICS.keys()})")
    ranking_json = RANKING_METRICS_JSON[metric]
    if ranking_json not in rankings:
        raise AssertionError(f"metric {metric} not found in rankings JSON file {ranking}")
    keys = list(rankings[ranking_json].keys())
    if not use_recycled:
        keys = [key for key in rankings[ranking_json].keys() if "_recycled_" not in key]
    best_score = max([rankings[ranking_json][key] for key in keys])
    best_model = list(rankings[ranking_json].keys())[list(rankings[ranking_json].values()).index(best_score)]
    interaction_score = rankings["interface score"][best_model]
    interfacial_residue_number = rankings["interfacial residue number"][best_model]
    interfacial_contact_number = rankings["interficial contact number"][best_model]
    pitms = rankings["pitms"][best_model]
    plddts = rankings["plddts"][best_model]
    ptms = rankings["ptms"][best_model]
    return Ranking(best_model, interaction_score, interfacial_residue_number, interfacial_contact_number,
                   pitms, plddts, ptms)


def parse_mapping(mapping_file: TextIO, source_column: int = 0, converted_column: int = 1) \
        -> dict[str, str]:
    """
    Parse mapping file.

    :param mapping_file: text delimited filename
    :param source_column: index of source id columns
    :param converted_column: index of converted id columns
    :return: dictionary of source id to converted id
    """
    mappings = {}
    for line in mapping_file:
        if line.startswith('#'):
            continue
        columns = line.rstrip('\r\n').split('\t')
        source = columns[source_column]
        converted = columns[converted_column]
        if converted:
            mappings[source] = converted
    return mappings


if __name__ == '__main__':
    main()
